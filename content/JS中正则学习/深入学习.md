# 一、字符匹配

正则表达式是模式匹配，要么匹配字符，要么匹配位置。
## 1.1 两种模糊匹配
如果正则只有精确匹配是没什么意义的，正则之所以强大，是因为实现模糊匹配。    
模糊匹配分为：横向模糊和纵向模糊。
###  1.1.1 横向模糊匹配
横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。    
实现方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多出现n次。    
比如正则/ab{2,4}c/, 表示匹配这样的字符串：第一个字符是"a"，接下来是2到4个字符"b"，最后是一个字符"c"。    
```
实例：
    var reg = /ab{2,4}c/g;
    var str = "abc abbc abbbc abbbbc abbbbbc";
    console.log(str.match(reg));  // =>["abbc","abbbc","abbbbc"]
```
说明：正则中的g(global)是正则的一个修饰符，表示全局匹配。即，在目标字符串中按顺序找到满足匹配模式的所有字符串，强调所有，而不只是第一个。
### 1.1.2 纵向模糊匹配
纵向模糊匹配指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。    
实现方式是使用字符组。譬如[abc]，表示该字符可以是字符“a”，“b”，“c”中的任何一个。    
比如正则/a[123]b/，可以匹配“a1b”，“a2b”，“a3b”这三种字符串。
```
实例：
    var reg = /a[123]b/g;
    var str = "a0b a1b a2b a3b a4b";
    console.log(str.match(reg));  // =>["a1b","a2b","a3b"]
```
## 1.2 字符组
虽叫字符组，但只是其中一个字符。    
例如 [abc]，表示匹配一个字符，可以是“a”，“b”，“c”中的任何一个。    
### 1.2.1 范围表示法
如果字符组里的字符特别多的话，可以使用范围表示法。    
比如[123456abcdefgHIGKLMN],可以写成[1-6a-gH-N]。用连字符"-"来省略和简写。    
以为连字符有特殊的含义，如果需要匹配连字符，要么放在开头，要么放在结尾，要么转义，总之不会让引擎认为是范围表示法就行了。    
比如要匹配"a","-","b"中任意一个字符，可以写成：[ab-]/[-ab]/[a\-b]。
### 1.2.2 排除字符组
排除字符组(反义字符组): 在纵向模糊匹配中，某位字符可以是除指定字符以外的任意字符。   
例如：[^abc]，表示是一个除"a","b","c"之外的任意一个字符。字符组的第一位放 ^ 表示求反的概念。    
### 1.2.3 常见的简写形式
| 字符组 | 具体含义|
| ----------- |--------------------------|
| \d | 表示[0-9]，表示是一位数字。 记忆方法：digit缩写。 |
| \D | 表示[^0-9]，表示除数字以外的任意字符 。|
| \w | 表示[0-9a-zA-Z_]，表示数字、大小写字母和下划线。也称单词字符。记忆方法：word的缩写。|
| \W | 表示[^0-9a-zA-Z_]，表示非单词字符。|
| \s | 表示[\t\v\n\r\f]，表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 记忆方法：s是space的首字母，空白符的单词 white space。|
| \S | 表示[^\t\v\n\r\f]，表示非空白符。|
| .  | 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。|    

如果要匹配任意字符可以使用[\d\D]、[\s\S]、[\w\W]和[^]中任何一个。
## 1.3 量词
也就是字符重复的次数。
### 1.3.1 简写形式
| 量词 | 具体含义|
| ----------- |--------------------------|
| {m,} | 表示至少出现m次。 |
| {m} | 表示出现m次。|
| ? | 等价{0,1}，表示出现或者不出现。|
| + | 等价{1,}，表示至少出现一次。|
| * | 等价于{0,}，表示出现任意次，有可能不出现。|    
### 1.3.2 贪婪匹配与惰性匹配
贪婪匹配，会尽量多的匹配，只要在能力范围内，越多越好。
```
实例：
    var reg = /\d{2,5}/g;
    var str = "123 1234 12345 123456";
    console.log(str.match(reg));  // =>["123","1234","12345","123456"]
```
其中正则/\d{2,5}/g，表示数字连续出现2到5次。会匹配2位，3位，4位，5位连续数字。        

惰性匹配，就是尽可能少的匹配。
```
实例：
    var reg = /\d{2,5}?/g;
    var str = "123 1234 12345 123456";
    console.log(str.match(reg));  // =>["12","12","34","12","34","12","34","56"]
```
其中正则/\d{2,5}?/g，表示虽然2到5次都行，当两个就够的时候就不再往下尝试了。