# 一、字符匹配

正则表达式是模式匹配，要么匹配字符，要么匹配位置。
## 1.1 两种模糊匹配
如果正则只有精确匹配是没什么意义的，正则之所以强大，是因为实现模糊匹配。    
模糊匹配分为：横向模糊和纵向模糊。
###  1.1.1 横向模糊匹配
横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。    
实现方式是使用量词。譬如{m,n}，表示连续出现最少m次，最多出现n次。    
比如正则/ab{2,4}c/, 表示匹配这样的字符串：第一个字符是"a"，接下来是2到4个字符"b"，最后是一个字符"c"。    
```
实例：
    var reg = /ab{2,4}c/g;
    var str = "abc abbc abbbc abbbbc abbbbbc";
    console.log(str.match(reg));  // =>["abbc","abbbc","abbbbc"]
```
说明：正则中的g(global)是正则的一个修饰符，表示全局匹配。即，在目标字符串中按顺序找到满足匹配模式的所有字符串，强调所有，而不只是第一个。
### 1.1.2 纵向模糊匹配
纵向模糊匹配指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种可能。    
实现方式是使用字符组。譬如[abc]，表示该字符可以是字符“a”，“b”，“c”中的任何一个。    
比如正则/a[123]b/，可以匹配“a1b”，“a2b”，“a3b”这三种字符串。
```
实例：
    var reg = /a[123]b/g;
    var str = "a0b a1b a2b a3b a4b";
    console.log(str.match(reg));  // =>["a1b","a2b","a3b"]
```
## 1.2 字符组
虽叫字符组，但只是其中一个字符。    
例如 [abc]，表示匹配一个字符，可以是“a”，“b”，“c”中的任何一个。    
### 1.2.1 范围表示法
如果字符组里的字符特别多的话，可以使用范围表示法。    
比如[123456abcdefgHIGKLMN],可以写成[1-6a-gH-N]。用连字符"-"来省略和简写。    
以为连字符有特殊的含义，如果需要匹配连字符，要么放在开头，要么放在结尾，要么转义，总之不会让引擎认为是范围表示法就行了。    
比如要匹配"a","-","b"中任意一个字符，可以写成：[ab-]/[-ab]/[a\-b]。
### 1.2.2 排除字符组
排除字符组(反义字符组): 在纵向模糊匹配中，某位字符可以是除指定字符以外的任意字符。   
例如：[^abc]，表示是一个除"a","b","c"之外的任意一个字符。字符组的第一位放 ^ 表示求反的概念。    
### 1.2.3 常见的简写形式
| 字符组 | 具体含义|
| ----------- |--------------------------|
| \d | 表示[0-9]，表示是一位数字。 记忆方法：digit缩写。 |
| \D | 表示[^0-9]，表示除数字以外的任意字符 。|
| \w | 表示[0-9a-zA-Z_]，表示数字、大小写字母和下划线。也称单词字符。记忆方法：word的缩写。|
| \W | 表示[^0-9a-zA-Z_]，表示非单词字符。|
| \s | 表示[\t\v\n\r\f]，表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符。 记忆方法：s是space的首字母，空白符的单词 white space。|
| \S | 表示[^\t\v\n\r\f]，表示非空白符。|
| .  | 通配符，表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外。|    

如果要匹配任意字符可以使用[\d\D]、[\s\S]、[\w\W]和[^]中任何一个。
## 1.3 量词
也就是字符重复的次数。
### 1.3.1 简写形式
| 量词 | 具体含义|
| ----------- |--------------------------|
| {m,} | 表示至少出现m次。 |
| {m} | 表示出现m次。|
| ? | 等价{0,1}，表示出现或者不出现。|
| + | 等价{1,}，表示至少出现一次。|
| * | 等价于{0,}，表示出现任意次，有可能不出现。|    
### 1.3.2 贪婪匹配与惰性匹配
贪婪匹配，会尽量多的匹配，只要在能力范围内，越多越好。
```
实例：
    var reg = /\d{2,5}/g;
    var str = "123 1234 12345 123456";
    console.log(str.match(reg));  // =>["123","1234","12345","123456"]
```
其中正则/\d{2,5}/g，表示数字连续出现2到5次。会匹配2位，3位，4位，5位连续数字。        

惰性匹配，就是尽可能少的匹配。
```
实例：
    var reg = /\d{2,5}?/g;
    var str = "123 1234 12345 123456";
    console.log(str.match(reg));  // =>["12","12","34","12","34","12","34","56"]
```
其中正则/\d{2,5}?/g，表示虽然2到5次都行，当两个就够的时候就不再往下尝试了。    
通过在量词后面加个问号就能实现惰性匹配。  
## 1.4 多选分支
一个模式可以实现横向和纵向模式匹配。多选分支可以支持多个子模式任选其一。    
具体形式(p1|p2|p3)，其中p1、p2、p3是子模式，用|(管道符)，表示其中任何之一。
```
实例：
    var reg = /good|better/g;
    var str = "good idea, better method";
    console.log(str.match(reg));  // => ["good","better"]
```  
如果遇到这种情况：
```
    var reg = /good|goodbye/g;
    var str = "goodbye";
    console.log(str.match(reg));  // => ["good"]
```
而应把正则规则做调整：
```
    var reg = /goodbye|good/g;
    var str = "goodbye";
    console.log(str.match(reg));  // => ["goodbye"]
```
可以看出，分支结构时惰性匹配的，即当前面的匹配上了，后面的就不再尝试了。
## 1.5 实例
字符匹配也就是字符组、量词和分支结构的组合使用。    
### 1.5.1 匹配16进制颜色值
需要匹配的字符
```
#ffccde
#Fc01DF
#FFF
#f39
```
分析：    
表示16进制字符，可以用字符组[0-9a-fA-F]。     
其中字符可以出现三次或6次，需要使用量词和分支结构。使用分支结构时需要注意顺序。    
```
var reg = /#([0-9a-fA-F]{6})|([0-9a-fA-F]{3})/g;
var str = "#ffccde #Fc01DF #FFF #f39";
console.log(str.match(reg));  // => ["#ffccde","#Fc01DF ","#FFF","#f39"]
```
### 1.5.2 匹配时间
需要匹配的字符
```
23:59
08:30
```
分析：    
共四位数字，第一位数字可以为[0-2],    
当第一位为2时，第二位可以为[0-3]，其他情况时，第二位可以为[0-9],    
第三位数字可以为[0-5],    
第四位数字可以为[0-9]。
```
var reg = /^([01]\d)|([2][0-3]):[0-5]\d$/;
console.log(reg.test("23:59"));  // => true
console.log(reg.test("08:30"));  // => true
```
正则中的^和$，分别表示字符串开头和结尾。    
如若需要匹配：    
8:30
```
    var reg = /^(0?[0-9]|[1][0-9]|[2][0-3]):[0-5]\d$/;
    console.log(reg.test("8:30"));  // => true
```
### 1.5.3 匹配日期
匹配的时间格式 yyyy-mm-dd。    
需要匹配的字符
```
2018-07-04
```
分析：    
年，四位数字，[0-9]{4};    
月，12个月分两种情况“01”...“09”，和“10”、“11”、“12”，可用(0[1-9]|1[0-2])。    
日，最大31，可用(0[1-9]|[12][0-9]|3[01])。
```
    var reg = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
    console.log(reg.test("2018-07-04"));  // => true
```
### 1.5.4 windows文件路径
需要匹配的字符
```
  F:\study\javascript\regex\regular expression.pdf
  F:\study\javascript\regex\
  F:\study\javascript
  F:\
```
分析：    
整体模式： 盘符:\文件夹\文件夹\    
其中匹配F:\，需要使用[a-zA-Z]:\\\\，盘符不区分大小写，\ 需要转义。    
文件夹名和文件夹名不能包含一些特殊字符，排除特殊字符来表示合法的名称，需要使用[^\\\\:\*\<\>\|\"\?\\r\\n\/]。    
文件夹名字不能为空，至少需要包含一个字符，也就是需要使用+。    
匹配 文件夹\ 就需要使用 [^\\\\:\*\<\>\|\"\?\\r\\n\/]+\\\\。    
另外 文件夹\可以出现任意次。也就是([^\\\\:\*\<\>\|\"\?\\r\\n\/]+\\\\)*，括号表示内部是一个整体。    
路径的最后一部分可以是文件夹，没有\，因此需要添加([^\\\\:\*\<\>\|\"\?\\r\\n\/]+)?。
```
  var reg = /^[a-zA-Z]:\\([^\\:*<>|"?\r\n/]+\\)*([^\\:*<>|"?\r\n/]+)?$/;
  console.log(reg.test("F:\\study\\javascript\\regex\\regular expression.pdf"));  // => true
  console.log(reg.test("F:\\study\\javascript\\regex\\"));  // => true
  console.log(reg.test("F:\\study\\javascript"));  // => true
  console.log(reg.test("F:\\"));  // => true
```
**注意字符转义**
### 1.5.5 匹配 id
目标: 提取id="container"
```
    <div id="container" class="main"></div>
```
首先想到的做法：   
```
    var reg = /id=".*"/;
    var str = '<div id="container" class="main"></div>';
    console.log(str.match(reg)[0]); // => id="container" class="main"
```
因为.是通配符，本身就匹配双引号，量词*又是惰性匹配，当遇到container后面的双引号时不会停止，直到遇到最后的双引号时才结束。    
使用惰性匹配：
```
    var reg = /id=".*?"/;
    var str = '<div id="container" class="main"></div>';
    console.log(str.match(reg)[0]); // => id="container"
```
这种方式效率较低，后面继续完善。