## 什么是闭包
《JavaScript高级程序设计》描述
 >闭包是指有权访问另外一个函数作用域中变量的函数。

《JavaScript权威指南》描述    
>从技术的角度讲，所有的JavaScript函数都是闭包: 它们都是对象，它们都关联到作用域链。    

《你不知道的JavaScript》描述
>当函数可以记住并访问所在词法作用域时，就产生了闭包，即使函数在当前词法作用域之外执行。   

MDN描述
>闭包是指那些能够访问自由变量的函数。自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量。    


个人感觉第三种描述更容易理解，闭包是基于词法作用域书写代码时产生的自然结果，是一种现象。

## 闭包的解释
**当函数可以记住并访问所在词法作用域时，就产生了闭包，即使函数在当前词法作用域之外执行。**     
```
function foo(){
    var name = 'hello';
    function bar(){
        console.log(name)
    }
    bar()
}
foo()
```
根据《JavaScript高级程序设计》和《JavaScript权威指南》来说，bar访问到了foo的变量，满足了“有权访问另外一个函数作用域中变量的函数”，bar本身就是一个函数，满足了“所有的JavaScript函数都是闭包”，的确是闭包，但是这种方式定义的闭包不容易观察。
```
// 通过返回函数的形式
function f1(){
    var name = 'world';
    function f2(){
        console.log(name);
    }
    return f2;
}
var f3 = f1();
f3();
```
这样清晰的展示了闭包：
- f2的词法作用域能访问到f1作用域的变量
- 将f2当做值返回
- f1执行后，将f2的引用赋值给f3
- 执行f3，输出了变量name    

通过引用的关系，f3就是f2本身，执行f3后能正常输出name，也就是说f2能记住并访问它所在的词法作用域，而且f2函数的运行环境是在当前词法作用域之外了。   

正常来说，当f1函数执行完毕之后，其作用域是会被销毁的，然后垃圾回收器会释放那段内存空间。而闭包却使得f1的作用域存活下来，f2依然持有该作用域的引用，这个引用就是闭包。    
总的来说：某个函数在定义时的词法作用域之外的地方被调用，闭包可以使该函数访问定义时的词法作用域。    

对函数值的传递可以通过其他的方式，不一定只有返回该函数，还可以通过回调函数：
```
// 通过回调函数的形式
function fn1(){
    var name = '闭包';
    function fn2(){
        console.log(name);
    }
    fn3(fn2)
}
function fn3(fn){
    fn();
}
fn1();
```
所以无论通过哪种方式将内部的函数传递到所在词法作用域以外，它都会持有对原始作用域的引用，无论在何处执行这个函数都会使用闭包。    

