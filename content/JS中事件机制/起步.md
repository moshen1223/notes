## 前言
JavaScript从诞生之日起就是一门单线程的非阻塞的脚本语言。**单线程**意味着，JavaScript代码在执行的时候，只有一个主线程来处理所有的任务。 **非阻塞**则是当代码需要进行一项异步任务的时候，主线程会挂起这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。    
JavaScript引擎通过 **事件循环(Event Loop)** 实现非阻塞特点。    

## 浏览器环境下js引擎的事件循环机制
### 执行栈与事件队列
JavaScript代码执行的时候会将变量存于内存的不同位置:堆(heap)和栈(stack)中加以区分。其中堆里边存放着一些对象，栈里边存放着一些基础类型变量以及对象的指针。    
当调用一个方法的时候，js会生成一个与这个方法对应的执行环境(context)，又叫执行上下文。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方，这个地方被称为执行栈。    
当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行，如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码执行完毕并返回结果后，js会退出这个执行环境并销毁这个执行环境，回到上一个方法的执行环境。反复执行这个过程，直到执行栈中的代码全部执行完毕。    
上边所描述的是同步代码的执行，异步代码的执行使用js的非阻塞特点，非阻塞的关键机制----事件队列。    
js引擎遇到一个异步事件后不会一直等待其返回结果，而是将这个事件挂起，继续执行**执行栈**中其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另外一个队列，称之为事件队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕，主线程处于闲置状态时，主线程会查找事件队列是否有任务，如果有，那么会从中取出排在第一个的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，就形成了一个无限的循环，这个过程被称为"事件循环"。
   
### 微任务(micro task)与宏任务(macro task)
实际上异步任务执行之间并不相同，执行优先级有区别，不同的异步任务被分为微任务和宏任务。    
宏任务：setInterval()、setTimeout()    
微任务：new Promise()    
在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。根据这个异步事件的类型，这个事件实际上会被放入对应的宏任务或微任务队列中去。并且在当前执行栈为空的时候，主线程会查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出前面的一个事件，把对应的回调加入当期执行栈，如此反复，进入循环。
